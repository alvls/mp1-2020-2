/*Разработать программу, реализующую игру «Быки и коровы».
Требования (правила)

	Играют два игрока (человек и компьютер).
	Игрок выбирает длину загадываемого числа – n (от 2 до 5).
	Компьютер «задумывает» n-значное число с неповторяющимися цифрами.
	Игрок делает попытку отгадать число – вводит n-значное число с неповторяющимися цифрами.
	Компьютер сообщает, сколько цифр угадано без совпадения с их позициями в загаданном числе (то есть количество коров) и
	сколько угадано вплоть до позиции в загаданном числе (то есть количество быков).
	Игрок делает попытки, пока не отгадает всю последовательность или не сдастся.

Пример

	Пусть n = 4.
	Пусть задумано число «3219».
	Игрок ввел число «2310».
	Результат: две «коровы» (две цифры: «2» и «3» — угаданы на неверных позициях) и один «бык» (одна цифра «1» угадана вплоть до позиции).*/

	//Подключение библиотек 
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <math.h>
//Размер массива
#define ARRAY_SIZE 5
#define MAX_INT

/*Для сложного режима. Максимальное число попыток. Сделано для того, чтобы можно было выводить таблицу с попытками
Максимально допустимое значение для MAX_POP = 9*9*8*7*6 = 27216. Рекомендуется не превышать данную величину*/
#define MAX_POP1 128
#define MAX_POP2 64
#define MAX_POP3 32
#define MAX_POP4 16
#define MAX_POP5 8
#define MAX_POP6 4
#define MAX_MAX_POP 6 //Сколько всего MAX_POP существует
int arrayofmaxpop[MAX_MAX_POP] = { MAX_POP1, MAX_POP2 ,MAX_POP3, MAX_POP4 , MAX_POP5, MAX_POP6 }; //Если что-нибудь изменится, то сюда нужно обязательно посмотреть

/*От автора: почти все части кода заключены в { }.
Это создано для удобства, потому что данная махинация позволяет скрывать проверенные части
и концентрировать внимание только на том, где нужно что-то исправить/понять */

//Функция для подсчёта количества попыток
int maxpopitok(int sloz, int n)
{
	int attempt = 0;
	switch (n)
	{
	case 2:
		attempt = arrayofmaxpop[n + sloz - 2];
		break;
	case 3:
		attempt = arrayofmaxpop[n + sloz - 3];
		break;
	case 4:
		attempt = arrayofmaxpop[n + sloz - 5];
		break;
	case 5:
		attempt = arrayofmaxpop[n + sloz - 6];
		break;
	}
	return(attempt);
}

//Функция для вывода сложности
int slozhnost(int sloz)
{
	printf("Выбранная сложность: ");
	switch (sloz)
	{
	case 1:
	{
		printf("Очень легко (+2 очка в случае выигрыша, -1 в случае поражения)\n");
		break;
	}
	case 2:
	{
		printf("Легко (+4 очка в случае выигрыша, -2 в случае поражения)\n");
		break;
	}
	case 3:
	{
		printf("Нормально (+8 очков в случае выигрыша, -4 в случае поражения)\n");
		break;
	}
	case 4:
	{
		printf("Сложно (+16 очков в случае выигрыша, -8 в случае поражения)\n");
		break;
	}
	case 5:
	{
		printf("Очень сложно (+32 очка в случае выигрыша, -16 в случае поражения)\n");
		break;
	}
	default:
	{
		printf("\nОшибка, которая связана со сложностями\n"); //проверка работоспособности кода
		break;
	}
	}
	return (0);
}

//Функция для вывода условий
int terms(int sloz, int n, int rezhim)
{
	printf("Компьютер загадал %d-значное число\n", n);
	if (rezhim == 2)
	{
		slozhnost(sloz);
		printf("Количество попыток: %d\n", maxpopitok(sloz, n));
	}
}

//Вывод правил
int rule(int n)
{
	if ((n < 2) || (n > 5)) //Это условие нужно здесь, чтобы программа в начале выдала полные правила, а потом показала только что означают быки и коровы
		printf("Правила игры:\nИграют два игрока (человек и компьютер).\nИгрок выбирает длину загадываемого числа – n (от 2 до 5).\nКомпьютер задумывает n - значное число с неповторяющимися цифрами.\nИгрок делает попытку отгадать число – вводит n-значное число с неповторяющимися цифрами.\nКомпьютер сообщает, сколько цифр угадано без совпадения с их позициями в загаданном числе\n(то есть количество коров) и сколько угадано вплоть до позиции в загаданном числе\n(то есть количество быков).\nИгрок делает попытки, пока не отгадает всю последовательность или не сдастся \n(если не выберет усложнение для игры).");
	else
		printf("Корова - сколько цифр угадано без совпадения с их позициями в загаданном числе\nБык - сколько цифр угадано с совпадением с их позициями в загаданном числе\n");
}

//Проверка доступа к циклу while в момент, когда идёт подсчёт быков и коров
int dostup(int pop, int maxpop, int rezhim)
{
	int dostup;
	if (rezhim == 1)
		dostup = 1; // Так как бесконечное число попыток
	if ((rezhim == 2) && (pop < maxpop))
		dostup = 1; //Так как для данного режима существует ограничение по попыткам
	if ((rezhim == 2) && (pop >= maxpop))
		dostup = 0; //Так как количество попыток достигло максимального значения
	return(dostup);
}

//Главная функция
void notmain()
{
	setlocale(LC_ALL, "Russian");

	//Объявление переменных

	int rezhim; //Переключатель режима: обычный/с усложнением
	int sloz; // Выбор сложности, затем максимальное количество попыток
	int score = 0; // Показывает, сколько очков заработал игрок // Хотел реализовать через файл, чтобы можно было запоминать все игры на данном компьютере, но остановился на более лёгком варианте
	int n; // Длина загадываемого числа
	int mas[ARRAY_SIZE] = { 0 }; // Массив для создания числа
	int polznum; //Число, введённое пользователем
	int kolvopolzcifr; // Длина числа, введённого пользователем
	int polzmas[ARRAY_SIZE] = { 0 }; //Пользовательский массив цифр
	int maspop[MAX_INT] = { 0 }; //Массив всех чисел, введённых пользователем (если программу можно было бы сдать с режимами, то достаточно MAX_POP1)
	int popcow[MAX_INT] = { 0 }; //Количество быков и коров для каждой из попыток (если программу можно было бы сдать с режимами, то достаточно MAX_POP1)
	int popbik[MAX_INT] = { 0 };
	int i, j; //Переменные для цикла
	int bik; //Количество быков
	int cow; //Количество коров
	int pop; //Количество попыток на данный момент
	int maxpop; //Максимальное количество попыток для выбранной сложности
	int konec = 0; //Переменная для понимания когда закончить игру
	int vibor; //Переменная для анализа выборов пользователя

	while (konec != 333) //Код для выхода - 333
	{
		//Дружественный интерфейс
		{
			printf("Я бот, с которым можно поиграть в игру \"Быки и Коровы\"!\n");
			vibor = 0;
			n = 0;
			while ((vibor < 1) || (vibor > 3))
			{
				printf("Вы можете:\n1.Сыграть в игру \"Быки и Коровы\"\n2.Узнать правила игры\n3.Выйти из игры\n");
				scanf_s("%d", &vibor);
				if ((vibor < 1) || (vibor > 3))
				{
					printf("Данные введены некорректно\n");
					continue;
				}
				if (vibor == 3)
				{
					konec = 1;
					polznum = 0;
					break;
				}
				if (vibor == 2)
				{
					rule(0);
					vibor = 0; //Чтобы снова перейти в ветку while 
					continue;
				}
				if (vibor == 1)
				{
					printf("Хорошо, давайте приступим к игре\n");
					printf("Для начала выберите версию:\n\t1.Стандартная\n\t2.С уровнями сложности и очками\n");
					/*Эта махинация нужна мне, потому что я в последний момент прочитал условие и понял, что количество попыток
					должно быть неограничено (достаточно странно), сам код мне жалко было стирать, если Вы скажете удалить 2 режим так, чтобы не
					появилось багов, я удалю. Оставил для теста, вдруг заказчику понравится и он оставит эту штуку :)*/
					rezhim = 0;
					while ((rezhim < 1) || (rezhim > 2))
					{
						scanf_s("%d", &rezhim);
						if ((rezhim < 1) || (rezhim > 2))
						{
							printf("Данный режим не предусмотрен программой, пожалуйста, повторите попытку\n");
							continue;
						}
					}
				}
			}

		}

		//Игрок выбирает сложность игры и длину загадываемого числа – n (от 2 до 5).
		{
			sloz = 0;
			n = 0;
			vibor = 0;
			if (konec != 1)
			{
				while (vibor != 1)
				{
					vibor = 0; //Нужно занулить эту переменную, чтобы было меньше проблем в будущем
					while ((n < 2) || (n > ARRAY_SIZE))
					{
						printf("Выберите длину загадываемого числа (от 2 до 5)\n");
						scanf_s("%d", &n);
						if ((n < 2) || (n > ARRAY_SIZE))
							printf("Данные введены некорректно\n");
					}
					system("cls");
					if (rezhim == 2)
					{
						while ((sloz < 1) || (sloz > 5))
						{
							printf("Выберите уровень сложности:\n\t1.Очень легко     (попыток: %d, +2 очка в случае выигрыша, -1 в случае поражения)\n\t2.Легко           (попыток: %d, +4 очка в случае выигрыша, -2 в случае поражения)\n\t3.Нормально       (попыток: %d, +8 очков в случае выигрыша, -4 в случае поражения)\n\t4.Сложно          (попыток: %d, +16 очков в случае выигрыша, -8 в случае поражения)\n\t5.Очень сложно    (попыток: %d, +32 очка в случае выигрыша, -16 в случае поражения)\n", maxpopitok(1, n), maxpopitok(2, n), maxpopitok(3, n), maxpopitok(4, n), maxpopitok(5, n));
							//Можно было реализовать через функцию, чтобы здесь и потом выводилось через неё, но я отказался от этой идеи из-за того, что здесь я выровнял в два столбика, а дальше выравнивание не нужно
							scanf_s("%d", &sloz);
							if ((sloz < 1) || (sloz > 5))
							{
								system("cls");
								printf("Данные введены некорректно\n");
								continue;
							}
							system("cls");
							//printf("%d\n", sloz);//проверка работоспособности кода
						}
					}
					while ((vibor < 1) || (vibor > 3))
					{
						if (rezhim == 1)
						{
							vibor = 1;
							system("cls");
							printf("Итак, ваши настройки:\n");
							terms(sloz, n, rezhim);
							break;
						}
						terms(sloz, n, rezhim);
						printf("\nВы довольны выбранной конфигурацией?\n\t1.Да, не нужно ничего менять\n\t2.Нет, я бы хотел изменить количество цифр в числе\n\t3.Нет, я бы хотел изменить сложность\n");
						scanf_s("%d", &vibor);
						if ((vibor < 1) || (vibor > 3))
						{
							system("cls");
							printf("Данные введены некорректно\n");
							continue;
						}
						if (vibor == 2)
						{
							n = ARRAY_SIZE + 1; //Изменяется значение, чтобы заново войти в цикл while для выбора количества цифр
							system("cls");
							printf("Хорошо\n");
							continue;
						}
						if (vibor == 3)
						{
							sloz = 10; //Изменяется значение, чтобы заново войти в цикл while для сложности
							system("cls");
							printf("Хорошо\n");
							continue;
						}
						if (vibor == 1)
						{
							system("cls");
							printf("Итак, ваши настройки:\n");
							terms(sloz, n, rezhim);
						}
					}
				}
			}
		}

		//Компьютер «задумывает» n-значное число с неповторяющимися цифрами.
		{
			if (konec != 1)
			{
				srand(time(NULL));
				for (i = 0; i < n; i++)
				{
					if (i != 0)
					{
						mas[i] = rand() % 10; //Рандомим цифры, следующие после первой
					}
					else
					{
						mas[i] = rand() % 9 + 1; //Рандомим первую цифру в диапазоне от 1 до 9, ибо любое целое число не начинается с "0"
					}

					//printf("Цифра %d: %d\n", i+1, mas[i]); //проверка работоспособности кода

					for (j = 0; j < i; j++)
					{
						if (mas[i] == mas[j])
						{
							i--; //В конце у нас выполняется i++, эта строчка позволит оставить i неизменной для новой генерации
							break;
						}
					}
				}
			}
		}


		//Для разработчика
		{
			if (konec != 1)
			{
				printf("Компьютер загадал число: ");
				for (i = 0; i < n; i++)
					printf("%d", mas[i]);
				printf("\n");
			}
		}

		//Игрок делает попытку отгадать число – вводит n - значное число с неповторяющимися цифрами. + Подсчёт быков и коров
		{
			if (konec != 1)
			{
				bik = 0;
				pop = 0;
				maxpop = maxpopitok(sloz, n);
				while ((bik != n) && (dostup(pop, maxpop, rezhim) == 1) && (konec != 1))
				{
					polznum = 0;
					while ((polznum < 1) || (polznum > 99999))
					{
						printf("Введите ");
						if (pop != 0)
						{
							printf("новое ");
						}
						printf("%d-значное целое число с неповторяющимися цифрами (чтобы сдаться, введите 1): ", n);
						scanf_s("%d", &polznum);
						if ((polznum < 1) || (polznum > 99999))
							printf("Данные введены некорректно\n");
					}
					if (polznum == 1)
					{
						konec = 1;
						break;
					}
					maspop[pop] = polznum;
					//Создаём массив из данных, введённых пользователем
					i = n - 1;
					kolvopolzcifr = 0;
					while (polznum > 0)
					{
						polzmas[i] = polznum % 10;
						//printf("Цифра %d: %d\n", i+1, polzmas[i]); //проверка работоспособности кода
						polznum = polznum / 10;
						//printf("Само число: %d\n", polznum); //проверка работоспособности кода
						i--;
						kolvopolzcifr++;
					}
					if (kolvopolzcifr != n)
					{
						printf("Вы ввели %d-значное число - оно не является %d-значным\n", kolvopolzcifr, n);
						continue;
					}
					bik = 0;
					cow = 0;
					for (i = 0; i < n; i++)
					{
						for (j = 0; j < n; j++)
						{
							if (mas[i] == polzmas[j])
							{
								if (i == j)
									bik++;
								else
									cow++;
							}
						}
					}
					//printf("Количество коров: %d\n", cow);//проверка работоспособности кода
					popcow[pop] = cow;     //Ошибка в этих переменных. После восьмой - десятой попытки массив изменяется не так, как нужно
					//printf("Количество быков: %d\n", bik);//проверка работоспособности кода
					popbik[pop] = bik; //Через отладчик я не нашёл никаких проблем, проходил через него многовато раз (может быть, во мне работает чувство уверенности, что я всё написал правильно, которое блокирует реальный расклад вещей), поэтому я просто перепишу код с сухим одним режимом (да, из-за того, что не смог реализовать вывод данных на экран в виде таблицы - там не буду это использовать)
					pop++;
					system("cls"); //Можно было реализовать вывод попыток в виде таблицы лишь по просьбе пользователя, но (продолжение в комментарии ниже), поэтому это сделало бы код огромнее
					terms(sloz, n, rezhim);
					rule(n);
					printf("\tВаши попытки:\n"); //Я не смог запихнуть в функцию двумерный массив (который потом пришлось расформировать на два массива), поэтому не реализовал просмотр попыток с помощью функции
					printf(" Попытка  Значение  Коров  Быков \n");
					for (int i = 0; i < pop; i++)
					{
						printf("%5d %10d %6d %6d\n", i + 1, maspop[i], popcow[i], popbik[i]);
					}
				}
				if (bik == n)
				{
					printf("Поздравляю, вы отгадали загаданное число!\n");
					printf("Затраченное число попыток: %d из %d\n", pop, maxpop);
					printf("\tВаши попытки:\n"); //Можно запихнуть в функцию, но для этого нужно передать двумерный массив
					printf(" Попытка  Значение  Коров  Быков \n");
					for (int i = 0; i < pop; i++)
					{
						printf("%5d %10d %6d %6d\n", i + 1, maspop[i], popcow[i], popbik[i]);
					}
					if (rezhim == 2)
					{
						switch (sloz)
						{
						case 1:
							score += 2;
							break;
						case 2:
							score += 4;
							break;
						case 3:
							score += 8;
							break;
						case 4:
							score += 16;
							break;
						case 5:
							score += 32;
							break;
						}
						printf("Количество очков за сессию: %d", score);
						int maspop[MAX_INT] = { 0 };
						int popcowbik[MAX_INT][1] = { 0 };
					}
				}
				if (dostup(pop, maxpop, rezhim) == 1)
				{
					system("cls");
					if (rezhim != 1)
						printf("Вы ичерпали допустимое количество попыток (%d) для сложности (%d)!\n", maxpop, sloz);
					printf("Компьютер загадал число: ");
					for (i = 0; i < n; i++)
						printf("%d", mas[i]);
					printf("\n");
					if (pop != 0)
					{
						printf("\tВаши попытки:\n"); //Можно запихнуть в функцию, но для этого нужно передать двумерный массив
						printf(" Попытка  Значение  Коров  Быков \n");
						for (int i = 0; i < pop; i++)
						{
							printf("%5d %10d %6d %6d\n", i + 1, maspop[i], popcow[i], popbik[i]);
						}
					}
					printf("Не расстраивайтесь! В следующий раз у Вас точно получится!\n");
					if (rezhim != 1)
					{
						switch (sloz)
						{
						case 1:
							score -= 1;
							break;
						case 2:
							score -= 2;
							break;
						case 3:
							score -= 4;
							break;
						case 4:
							score -= 8;
							break;
						case 5:
							score -= 16;
							break;
						}
						printf("Количество очков за сессию: %d\n", score);
					}

				}
			}
		}
		if ((konec == 1) && (polznum != 1))
		{
			printf("Будем рады, если вы продолжите пользоваться нашим продуктом!\n");
			konec = 333; //Код для выхода из приложения
		}
		else
		{
			vibor = 0;
			polznum = 0;//На будущее
			int maspop[MAX_INT] = { 0 }; //На будущее
			int popcowbik[MAX_INT][1] = { 0 }; //На будущее
			while ((vibor < 1) || (vibor > 2))
			{
				printf("Мы можете выбрать:\n\t1.Вeрнуться в меню\n\t2.Завершить работу приложения\n");
				scanf_s("%d", &vibor);
				if ((vibor < 1) || (vibor > 2))
				{
					printf("Данные введены некорректно\n");
					continue;
				}
				if (vibor == 1)
					konec = 0;
				if (vibor == 2)
					konec = 333; //Код для выхода из программы
			}
		}
	}
	system("pause");
}
